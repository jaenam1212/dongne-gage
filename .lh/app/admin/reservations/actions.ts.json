{
    "sourceFile": "app/admin/reservations/actions.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1770983456677,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1770983615141,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -109,13 +109,22 @@\n     .single()\n \n   if (!shop) throw new Error('가게를 찾을 수 없습니다')\n \n+  // 상태별로 허용되는 현재 상태만 변경 (취소→완료 같은 잘못된 변경 방지)\n+  const allowedCurrentStatuses: Record<string, ('pending' | 'confirmed' | 'cancelled' | 'completed')[]> = {\n+    confirmed: ['pending'],\n+    cancelled: ['pending', 'confirmed'],\n+    completed: ['confirmed'],\n+  }\n+  const allowed = allowedCurrentStatuses[newStatus]\n+\n   const { error } = await supabase\n     .from('reservations')\n     .update({ status: newStatus })\n     .eq('shop_id', shop.id)\n     .in('id', reservationIds)\n+    .in('status', allowed)\n \n   if (error) throw new Error('일괄 상태 변경에 실패했습니다')\n \n   revalidatePath('/admin/reservations')\n"
                },
                {
                    "date": 1770983677653,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -109,12 +109,12 @@\n     .single()\n \n   if (!shop) throw new Error('가게를 찾을 수 없습니다')\n \n-  // 상태별로 허용되는 현재 상태만 변경 (취소→완료 같은 잘못된 변경 방지)\n+  // 상태별 허용: 취소→완료만 막고, 완료→취소(환불 등)는 허용\n   const allowedCurrentStatuses: Record<string, ('pending' | 'confirmed' | 'cancelled' | 'completed')[]> = {\n     confirmed: ['pending'],\n-    cancelled: ['pending', 'confirmed'],\n+    cancelled: ['pending', 'confirmed', 'completed'], // 완료→취소(환불) 허용\n     completed: ['confirmed'],\n   }\n   const allowed = allowedCurrentStatuses[newStatus]\n \n"
                }
            ],
            "date": 1770983456677,
            "name": "Commit-0",
            "content": "'use server'\n\nimport { revalidatePath } from 'next/cache'\nimport { createClient } from '@/lib/supabase/server'\nimport webpush from 'web-push'\n\nfunction ensureVapidDetails(): boolean {\n  const subject = process.env.VAPID_SUBJECT\n  const publicKey = process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY\n  const privateKey = process.env.VAPID_PRIVATE_KEY\n  if (subject && publicKey && privateKey) {\n    webpush.setVapidDetails(subject, publicKey, privateKey)\n    return true\n  }\n  return false\n}\n\nconst STATUS_MESSAGES = {\n  confirmed: '예약이 확인되었습니다',\n  cancelled: '예약이 취소되었습니다',\n  completed: '예약이 완료되었습니다',\n}\n\nexport async function updateReservationStatus(\n  reservationId: string,\n  newStatus: 'confirmed' | 'cancelled' | 'completed'\n) {\n  const supabase = await createClient()\n  const { data: { user } } = await supabase.auth.getUser()\n\n  if (!user) throw new Error('인증이 필요합니다')\n\n  const { data: reservation, error: fetchError } = await supabase\n    .from('reservations')\n    .select('*, shops!inner(owner_id, name, slug), products(title)')\n    .eq('id', reservationId)\n    .single()\n\n  if (fetchError || !reservation) {\n    throw new Error('예약을 찾을 수 없습니다')\n  }\n\n  if (reservation.shops.owner_id !== user.id) {\n    throw new Error('권한이 없습니다')\n  }\n\n  const { error } = await supabase\n    .from('reservations')\n    .update({ status: newStatus })\n    .eq('id', reservationId)\n\n  if (error) throw new Error('상태 변경에 실패했습니다')\n\n  try {\n    const { data: subscription } = await supabase\n      .from('push_subscriptions')\n      .select('*')\n      .eq('shop_id', reservation.shop_id)\n      .eq('customer_phone', reservation.customer_phone)\n      .single()\n\n    if (subscription && ensureVapidDetails()) {\n      await webpush.sendNotification(\n        {\n          endpoint: subscription.endpoint,\n          keys: {\n            p256dh: subscription.p256dh,\n            auth: subscription.auth,\n          },\n        },\n        JSON.stringify({\n          title: reservation.shops.name,\n          body: `${STATUS_MESSAGES[newStatus]} - ${reservation.products.title}`,\n          url: `/${reservation.shops.slug}`,\n        })\n      )\n    }\n  } catch (error: any) {\n    console.error('Push notification failed:', error)\n    if (error.statusCode === 410 || error.statusCode === 404) {\n      await supabase\n        .from('push_subscriptions')\n        .delete()\n        .eq('shop_id', reservation.shop_id)\n        .eq('customer_phone', reservation.customer_phone)\n    }\n  }\n\n  revalidatePath('/admin/reservations')\n  return { success: true }\n}\n\nexport async function updateReservationsStatusBulk(\n  reservationIds: string[],\n  newStatus: 'confirmed' | 'cancelled' | 'completed'\n) {\n  if (reservationIds.length === 0) {\n    return { error: '선택된 예약이 없습니다' }\n  }\n\n  const supabase = await createClient()\n  const { data: { user } } = await supabase.auth.getUser()\n  if (!user) throw new Error('인증이 필요합니다')\n\n  const { data: shop } = await supabase\n    .from('shops')\n    .select('id')\n    .eq('owner_id', user.id)\n    .single()\n\n  if (!shop) throw new Error('가게를 찾을 수 없습니다')\n\n  const { error } = await supabase\n    .from('reservations')\n    .update({ status: newStatus })\n    .eq('shop_id', shop.id)\n    .in('id', reservationIds)\n\n  if (error) throw new Error('일괄 상태 변경에 실패했습니다')\n\n  revalidatePath('/admin/reservations')\n  return { success: true }\n}\n"
        }
    ]
}